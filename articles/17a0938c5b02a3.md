---
title: "useEffectEvent関数は、useEffectの依存配列に含めてはいけない"
emoji: "📚"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["React", "TypeScript", "useEffect", "useEffectEvent"]
published: true
---

# はじめに

こちらを資料に追記したものになります。

https://speakerdeck.com/maguroalternative/react19-dot-2nouseeffecteventwozhui-u

間違った情報を記載してしまっていたので自省を込めて書いてます。
この記事も解釈間違っていたらご指摘いただけると幸いです。

https://twitter.com/sigumataityouda/status/1979173036151464031

# React19.2がリリース

2025/10/1にReact19.2がリリースされました。

https://react.dev/blog/2025/10/01/react-19-2

中でも新しいhooksである`useEffectEvent`が追加され、「stale closure問題」にメスが入るようになりました。

# stale closure問題

簡単に言えば、「古い状態を参照し続ける」ことを指します。
例えば以下のコードがあるとします。

```tsx
export function Example() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("add listener")
    const handler = () => {
      console.log(count); // ← ここが「古い値」になる
    };
    window.addEventListener('click', handler);
    return () => window.removeEventListener('click', handler);
  }, []);
  
  return <button onClick={() => setCount(c => c + 1)}>+1</button>;
}
```

:::message alert
上記のコードは`useEffect`なしで実装可能ですが、今回はあえて`useEffect`を使用しています。
:::

内容としては「クリックされるたびに`count`を`console`に表示する」ものになります。
`button`をクリックすると`count`がインクリメントされます。
一見、何ら問題ないように見えますが、コンソールを覗くと、、、

![](https://storage.googleapis.com/zenn-user-upload/95d36289b145-20251031.png)

はい。`count`が0のままです。
これは`useEffect`内での`count`がイベントハンドラ登録時のものを参照し続けているためです。
この状態を「stale closure問題」と言います。

一応の解決策としては、`useEffect`の依存配列に`count`を追加することなのですが、これはこれで別の問題があります。

```tsx
export function Example() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("add listener")
    const handler = () => {
      console.log(count); // ← ここが「古い値」になる
    };
    window.addEventListener('click', handler);
    return () => window.removeEventListener('click', handler);
  }, [count]);
  
  return <button onClick={() => setCount(c => c + 1)}>+1</button>;
}
```

これをコンソールで覗くと

![](https://storage.googleapis.com/zenn-user-upload/431ef1944cc7-20251031.png)

`count`は更新できましたが、新たに「add listener」の表示が毎回されるようになりました。
これは`count`が更新されるたびにイベントリスナーを登録していることになります。中身の`count`はその度に最新のものになりますが、わざわざそのためにイベントリスナーを再登録するのは余分です。

最新の`count`を参照させたいが、いちいちイベントリスナーを再登録させたくない、、、そんな時にこそ`useEffectEvent`の出番です。

```tsx
export function Example() {
  const [count, setCount] = useState(0);

  const handlerClick = useEffectEvent(() => {
    console.log(count);
  })

  useEffect(() => {
    console.log("add listener")
    window.addEventListener('click', handlerClick);
    return () => window.removeEventListener('click', handlerClick);
  }, []);
  
  return <button onClick={() => setCount(c => c + 1)}>+1</button>;
}
```

`useEffectEvent`を`handler`として新たに定義します。
前と異なる点として、`useEffect`の依存配列が空になっています。
依存関係がないので、初回レンダリング時にイベントリスナーが登録されるだけになります。

そうなると先ほどと同じく`count`の値は更新されないままと思いきや、、、？

![](https://storage.googleapis.com/zenn-user-upload/467de2ee1179-20251031.png)

はい、更新されています。
そう、`useEffectEvent`は常に最新の状態の`state`を取得してくれるのです。

# useEffectEventは依存配列に含まれない？

このコードを見て、違和感を持った方もいると思います。
`useEffectEvent`の関数を`useEffect`の依存配列に含めていないのです。

実際、linter[^1]も警告を出してくれてます。

![](https://storage.googleapis.com/zenn-user-upload/e7c4e02318d3-20251031.png)

![](https://storage.googleapis.com/zenn-user-upload/47fc1f864b4d-20251031.png)


なので、以下のように依存配列に含めるのが正かと思いきや、、、

```tsx
useEffect(() => {
  console.log("add listener useEffectEvent")
  window.addEventListener("click", handleClick);
  return () => window.removeEventListener("click", handleClick);
}, [handleClick]);
```

![](https://storage.googleapis.com/zenn-user-upload/eb5ae2189eb7-20251031.png)

はい、なんと**イベントリスナーが再登録されてしまいます。**
これは`handleClick`が毎回異なる関数を返すと言う意味にもなり、場合によっては無限ループを引き起こすことにもなります。

## なんでこんなことに？

以下のPRに詳細があります。

https://github.com/facebook/react/pull/25473

`useEffect`は外部システムと同期を行う役割を持つため、内部で使用する値や関数は依存配列に含めることが前提になっています。
`linter`が警告を出すのはそのためで、stale closure問題を引き起こすのを防ぐ役割を持ちます。

しかし`useEffectEvent`は最新の状態を持つことを保証してくれるhooksです。
常に最新の状態を持ってくれるのに、依存配列に含めることはおかしいのではないか？

そのため意図的に`useEffectEvent`は毎回異なる関数を返す実装になったそうです。

:::details もうちょい補足
当初は毎回新しい関数を返す実装ではなかったようです。
しかしその場合、以下のような状態が起こりえます。

- 依存配列あり
```tsx
  const handleClick = useEffectEvent(() => {
    console.log("最新の count:", count);
  });

  useEffect(() => {
    console.log("add listener useEffectEvent")
    window.addEventListener("click", handleClick);
    return () => window.removeEventListener("click", handleClick);
  }, [handleClick]);
```

- 依存配列なし
```tsx
  const handleClick = useEffectEvent(() => {
    console.log("最新の count:", count);
  });

  useEffect(() => {
    console.log("add listener useEffectEvent")
    window.addEventListener("click", handleClick);
    return () => window.removeEventListener("click", handleClick);
  }, []);
```

この2つのコードが**全く同じ挙動をすることになります。**

`useEffectEvent`の関数が外部システムなのか否かが曖昧になり、Reactの思想としてよろしくない状態になっています。

なのであえて新しい関数を返すことによって、外部システムではないことを示す実装になったらしいです。
:::

# まとめ

とりあえずこれだけ覚えておいてください。
- `useEffectEvent`関数は、(`useEffect`の外部システムに該当しないため)`useEffect`の依存配列に含めてはいけない。
- linterの更新も忘れずに、、、、
  - linterに騙されたと言ってますが、単純にlinterを更新してない自分のせいです、、、

https://twitter.com/sigumataityouda/status/1979469752784593164


[^1]: 最新のlinterは警告を出さないようです。
