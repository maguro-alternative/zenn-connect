---
title: "useEffectEvent関数は、useEffectの依存配列に含めてはいけない"
emoji: "📚"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

# はじめに

こちらを記事にしたものになります。

https://speakerdeck.com/maguroalternative/react19-dot-2nouseeffecteventwozhui-u

# React19.2がリリース

2025/10/1にReact19.2がリリースされました。

https://react.dev/blog/2025/10/01/react-19-2

中でも新しいhooksである`useEffectEvent`が追加され、「stale closure問題」にメスが入るようになりました。

# stale closure問題

簡単に言えば、「古い状態を参照し続ける」ことを指します。
例えば以下のコードがあるとします。

```tsx
export function Example() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("add listener")
    const handler = () => {
      console.log(count); // ← ここが「古い値」になる
    };
    window.addEventListener('click', handler);
    return () => window.removeEventListener('click', handler);
  }, []);
  
  return <button onClick={() => setCount(c => c + 1)}>+1</button>;
}
```

:::message alert
上記のコードはuseEffectなしで実装可能ですが、今回はあえてuseEffectを使用しています。
:::

内容としては「クリックされるたびにcountをconsoleに表示する」ものになります。
buttonをクリックするとcountがインクリメントされます。
一見、何ら問題ないように見えますが、コンソールを覗くと、、、

![](https://storage.googleapis.com/zenn-user-upload/95d36289b145-20251031.png)

はい。countが0のままです。
これはuseEffect内でのcountがイベントハンドラ登録時のものを参照し続けているためです。
この状態を「stale closure問題」と言います。

一応の解決策としては、useEffectの依存配列にcountを追加することなのですが、これはこれで別の問題があります。

```tsx
export function Example() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log("add listener")
    const handler = () => {
      console.log(count); // ← ここが「古い値」になる
    };
    window.addEventListener('click', handler);
    return () => window.removeEventListener('click', handler);
  }, [count]);
  
  return <button onClick={() => setCount(c => c + 1)}>+1</button>;
}
```

これをコンソールで覗くと

![](https://storage.googleapis.com/zenn-user-upload/431ef1944cc7-20251031.png)

countは更新できましたが、新たに「add listener」の表示が毎回されるようになりました。
これはcountが更新されるたびにイベントリスナーを登録していることになります。中身のcountはその度に最新のものになりますが、わざわざそのためにイベントリスナーを再登録するのは余分です。

最新のcountを参照させたいが、いちいちイベントリスナーを再登録させたくない、、、そんな時にこそ`useEffectEvent`の出番です。

```tsx
export function Example() {
  const [count, setCount] = useState(0);

  const handlerClick = useEffectEvent(() => {
    console.log(count);
  })

  useEffect(() => {
    console.log("add listener")
    window.addEventListener('click', handlerClick);
    return () => window.removeEventListener('click', handlerClick);
  }, []);
  
  return <button onClick={() => setCount(c => c + 1)}>+1</button>;
}
```

useEffectEventをhandlerとして新たに定義します。
前と異なる点として、useEffectの依存配列が空になっています。
依存関係がないので、初回レンダリング時にイベントリスナーが登録されるだけになります。

そうなると先ほどと同じくcountの値は更新されないままと思いきや、、、？

![](https://storage.googleapis.com/zenn-user-upload/467de2ee1179-20251031.png)

はい、更新されています。
そう、useEffectEventは常に最新の状態のstateを取得してくれるのです。

# useEffectEventは依存配列に含まれない？

このコードを見て、違和感を持った方もいると思います。
useEffectEventの関数をuseEffectの依存配列に含めていないのです。

実際、linter[^1]も警告を出してくれてます。

![](https://storage.googleapis.com/zenn-user-upload/e7c4e02318d3-20251031.png)

![](https://storage.googleapis.com/zenn-user-upload/47fc1f864b4d-20251031.png)


なので、以下のように依存配列に含めるのが正かと思いきや、、、

```tsx
useEffect(() => {
  console.log("add listener useEffectEvent")
  window.addEventListener("click", handleClick);
  return () => window.removeEventListener("click", handleClick);
}, [handleClick]);
```

![](https://storage.googleapis.com/zenn-user-upload/eb5ae2189eb7-20251031.png)

はい、なんと**イベントリスナーが再登録されてしまいます。**
これはhandleClickが毎回異なる関数を返すと言う意味にもなり、場合によっては無限ループを引き起こすことにもなります。

## なんでこんなことに？

以下のPRに詳細があります。

https://github.com/facebook/react/pull/25473

useEffectは外部システムと同期を行う役割を持つため、内部で使用する値や関数は依存配列に含めることが前提になっています。
linterが警告を出すのはそのためで、stale closure問題を引き起こすのを防ぐ役割を持ちます。

しかしuseEffectEventは最新の状態を持つことを保証してくれるhooksです。
常に最新の状態を持ってくれるのに、依存配列に含めることはおかしいのではないか？

そのため意図的にuseEffectEventは毎回異なる関数を返す実装になったそうです。

:::details もうちょい補足
当初は毎回新しい関数を返す実装ではなかったようです。
しかしその場合、以下のような状態が起こりえます。

- 依存配列あり
```tsx
  const handleClick = useEffectEvent(() => {
    console.log("最新の count:", count);
  });

  useEffect(() => {
    console.log("add listener useEffectEvent")
    window.addEventListener("click", handleClick);
    return () => window.removeEventListener("click", handleClick);
  }, []);
```

- 依存配列なし
```tsx
  const handleClick = useEffectEvent(() => {
    console.log("最新の count:", count);
  });

  useEffect(() => {
    console.log("add listener useEffectEvent")
    window.addEventListener("click", handleClick);
    return () => window.removeEventListener("click", handleClick);
  }, [handleClick]);
```

この2つのコードが**全く同じ挙動をすることになります。**

useEffectEventの関数が外部システムなのか否かが曖昧になり、reactの思想としてよろしくない状態になっています。

なのであえて新しい関数を返すことによって、外部システムではないことを示す実装になったらしいです。
:::

# まとめ

useEffectEvent関数は、useEffectの依存配列に含めてはいけない。

[^1]: 最新のlinterは警告を出さないようです。
