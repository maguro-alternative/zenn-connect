---
title: "TSKaigi 自分的まとめ"
emoji: "📝"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["TypeScript", "TSKaigi"]
published: false
---

TSKaigi Day1の自分のレポートです。

# Day1

## The New Powerful ESLint Config with Type Safety

https://talks.antfu.me/2025/tskaigi/1

- フラットコンフィグに関するお話
  - 従来に比べてシンプルなconfig。
  - TypeScriptベースで設定ファイルを構成可能に。
  - `.ts`による型安全な設定ができ、型定義や補完もサポート。
- eslint-plugin-command
  - コメントを読み取って自動的にフォーマットを行ってくれる。
  
https://github.com/antfu/eslint-plugin-command

個人的な感想として、jsonに依存しないconfigファイルの管理というのに衝撃を受けました。`package.json`もいずれ`package.ts`で管理できる時代が来るのかも...?

## スキーマと型で拓く Full-Stack TypeScript

https://speakerdeck.com/altech/tskaigi-2025

- ノーコードからTSに全面リプレイスし、スケーラブルな開発へ。
- フルスタックTSでありながらバックエンドとフロントを明確に分離し、GraphQLのスキーマ駆動で疎結合を実現。
- モノレポ構成だが各サービスは独立。
- 型による安全性を維持しつつ、開発環境やCICDも統一。
- 将来的な技術スタック変更にも柔軟に対応可能。

将来的にバックエンドがTSじゃなくなってもいいような構成にしていることが将来的な成長を見据えられて良いと思いました。
GraphQLによるスキーマ駆動にすることでバックとフロントの齟齬を埋め、バックを他言語にリプレイスするとしても同じくスキーマ駆動にしていけば、そこまで負荷も高く無くなるなと感心しました。
かつスピード感もフロントと同じTSを採用することで高速な開発が実現できており、TS採用の理由にも納得がいきます。

## TypeScriptでクリーンアーキテクチャを実践する - WebでもCLIでも使えるアプリケーションの作り方

https://speakerdeck.com/panda_program/clean-architecture-with-typescript-application

- クリーンアーキテクチャとは「方針と詳細を分けて、安定度の高い方針に依存する」
  - 方針とは、自身が何のアプリケーションなのか。
  - 詳細は差し替え可能。
- よく図で出てくる同心円はあくまでもサンプルでしかない。
- コアになるのは方針と詳細の分離。
  - 色々できてしまうのは良くないのでSOLID原則に従う。
  - 依存関係の逆転は良くない。
- 方針(ロジック)と詳細(Web or CLI)を分けることで、詳細が置き換わってもロジックが変わらない。
  - マルチプラットフォームに強い。

わかりやすくクリーンアーキテクチャの復習が出来ました。
一方で「ログイン機能を実装する」となるとWebにしかないセッションを、CLIでどうするかという点で依存性の逆転が起きてしまうのではないかとも思いました。

## AWS LambdaをTypeScriptで動かして分かった、Node.jsのTypeScriptサポートの利点と課題

https://speakerdeck.com/smt7174/aws-lambdawotypescriptdedong-kasitefen-katuta-node-dot-jsnotypescriptsapotonoli-dian-toke-ti

- Node.js 23.6以降ではトランスパイル不要でtypescriptが実行可能に（型除去が可能）。
- ts-node不要で高速化・パッケージ軽量化が可能だが、TSの一部機能（enumなど）非対応。
- aws lambdaではnode.js23.6は非対応 コンテナイメージなどで用意する必要あり。
  - aws sdkが読み込めずエラー。
  - デプロイパッケージが肥大化し、サイズ制限に引っかかる。
  - 上記2点により、lambdaでの実行には現時点で難がある。
- awsではnodeをサポートしてもtsはサポートしない サーバーレスではトランスコンパイルはまだ必須。
- v24で正式に対応するかも。

どういった部分で役立つかというのもありますが、自分としてはlambdaはそういった簡易的なfunctionを行うモノであると認識しているので、トランスコンパイルなしでtsが実行できるようになればlambdaの可能性が広がるのではないかと思いました。

## fast-checkとneverthrowのPBT+Result型で堅牢なビジネスロジックを実現する

https://speakerdeck.com/globeingoctagon/fast-checktoneverthrownopbt-plus-resultxing-de-jian-lao-nabizinesurozitukuwoshi-xian-suru

- ビジネスロジックの違反をどう伝えるか。
  - 例外か戻り値か。
  - 例外は楽だが、エラーの型がわからずどんな状況なのかわからない。
  - 複数の例外が発生すると何が原因か分かりづらくなる。
  - 戻り値は判別共用体を利用。
    - tsのunion活用。
  - どの型か判別することでエラー内容を判別可能。
- result型でokかerrか判別。
  - 型安全に成功したかエラーになったかを判別できる。
- 操作には骨が折れるので既存ライブラリを活用。
- メソッドチェーンで表現することで型安全に処理できる。

- プロパティベーステスト。
  - 性質に対してテスト。
    - 例として「ゼロでない値」「1文字以上7文字以下の英数字」など。
      - 要件を満たせるテストデータであればなんでも良い。

かなりGoの感覚に近いなーと思いました。
ただ発表にもあった通り大体のライブラリは例外を投げることが多いので、エラーを型判別する今回の事例は限定的になるかと考えられます。
とはいえ複雑なロジックを採用するフロントエンドやHonoを採用している場合は活用の余地はありそうです。

# Day2

## TypeScriptネイティブ移植観察レポート TSKaigi 2025

https://speakerdeck.com/berlysia/typescript-native-porting-observation-tskaigi-2025

- 観察しようとしたら昨日プレビューが出てしまってた。
- 実際動かしてみると、動くし早くなっている。
  - 動くので動かないと思ったらREADMEをみよう。
  - 大規模であるほど早く動く。
- Staradaは既存のTS実装。
  - TS6.x
- CorsaはGoによる実装。
  - TS7.0
- Corsaは早いという意味。
- また、10倍早くなるのはコンパイラ。
  - 間違えないように。
- なぜリプレイス？
  - 既存のJSコンパイラでは限界が来ている。
- Goに移植する理由。
  - TSの挙動はどこかのプロジェクトで利用されているという考えのもと。
    - ハイラムの法則と言うらしい。
  - 型チェッカーにて後方互換は絶対。
    - 古いコードでも新しいコンパイラでビルドできるべき。
    - Goとの相性がいい。
    - 「プラグアンドプレイで置き換えられるものを目指す」
- Goの理由。
  - 関数+データ構造での紐付き。
    - 肥大化しているcheck.tsの分割も可能。
  - GCを持ち、循環参照を自然に扱える。
  - 共有メモリでの並列処理が自然に可能。
  - クロスプラットフォームにネイティブコードで動作。
- 10倍の内訳。
  - ネイティブ3~3.5s * 並列処置3~3.5s
    - JITからの脱却
      - TSで型予想可能なのでチューニングしやすい。
    - 文字列管理効率化。
      - JSはUTF-16,GoはUTF-8。
        - 2バイトが1バイトになるため半分になる。
      - Goのスライスでメモリ割り当て発生しなくなる。
  - パース、バインドは並列できる処理でなのでgoroutineで対応可能。
  - GoランタイムスケジューラによりCPU数に対してスケーリング。
- 移植方法。
  - TSからGoへの変換ツールを作成し使用。
    - UnionやoptionalなどはGoには存在しないためそこは手動で修正。
    - AIベースの変換は一歳使われていない。
      - 補助としては使われた。
- 本家本元+動いて早くなってる。

